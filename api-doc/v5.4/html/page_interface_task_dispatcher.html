<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tomographer: TaskDispatcher Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tomographer_extra_css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tomographer
   &#160;<span id="projectnumber">v5.4</span>
   </div>
   <div id="projectbrief">Tomographer C++ Framework Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_interface_task_dispatcher.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TaskDispatcher Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The task dispatcher takes care of running tasks. It should handle tasks provided by a <a class="el" href="page_interface_task.html">Task Interface</a> compliant template parameter, should allow these tasks to share data via a <a class="el" href="page_interface_task_c_data.html">TaskCData Interface</a> compliant type also specified as template parameter.</p>
<dl class="section since"><dt>Since</dt><dd>Changed in Tomographer 5.0: Removed the results collector entirely. Now the tasks must be <a class="el" href="page_interface_resultable.html">Resultable</a> 's which the task dispatcher simply collects and make available to the caller with <em>collectedTaskResults()</em>.</dd></dl>
<h3>What the task dispatcher should do</h3>
<p>The task dispatcher is responsible for scheduling and running the tasks. See <a class="el" href="class_tomographer_1_1_multi_proc_1_1_sequential_1_1_task_dispatcher.html">Tomographer::MultiProc::Sequential::TaskDispatcher</a> for a simple example.</p>
<p>It should be provided, or should otherwise have knowledge of:</p>
<ul>
<li>A task type (<em>TaskType</em>), which obeys the <a class="el" href="page_interface_task.html">Task Interface</a> ;</li>
<li>A constant shared data structure (which we later refer to as <em>TaskCData</em>), which obeys the <a class="el" href="page_interface_task_c_data.html">TaskCData Interface</a> and which provides the necessary input data to carry out the tasks ;</li>
</ul>
<p>Upon execution, say within a <em>run()</em> method exposed by the task dispatcher, the task dispatcher is expected to do the following steps, in this order:</p>
<ul>
<li>Schedule the tasks however they are meant to be run (in different threads, in different processes, serially one at a time, etc.), and run each task following these steps:<ul>
<li>Get the input to the new task from the <em>TaskCData</em>, by invoking its <em>getTaskInput()</em> method;</li>
<li>Instantiate a new <em>TaskType</em> instance, providing it the input, as well as a suitable logger instance so that the task can log messages;</li>
<li>Run the task, by calling its <em>run()</em> function. You must provide a pointer to an object obeying the <a class="el" href="page_interface_task_manager_iface.html">TaskManagerIface Interface</a>, which allows the task to query whether status updates were requested. This object may be for instance a relevant private class or struct, it does not need to be public type. Theoretically, it could also be the task dispatcher itself (if it exposes the relevant methods), but this would mean having to publicly expose functions which should really only be called by the tasks. See <a class="el" href="class_tomographer_1_1_multi_proc_1_1_sequential_1_1_task_dispatcher.html">Tomographer::MultiProc::Sequential::TaskDispatcher</a> for an example.</li>
<li>Recover the task's result using its <em>stealResult()</em> or <em>getResult()</em> method.</li>
</ul>
</li>
<li><p class="startli">All the time during the above task execution, if the a status report is requested explicitly from an external caller (e.g. a signal handler) with a call to this class' <em>requestStatusReport()</em>, then the <em>TaskManagerIface</em> provided to the task's <em>run()</em> function should inform the task to provide its status report (see <a class="el" href="page_interface_task.html">Task Interface</a>).</p>
<p class="startli">When a status report is requested, the tasks will submit their reports to the <em>TaskManagerIface</em> (see <a class="el" href="page_interface_task.html">Task Interface</a>). Once all the reports are received, they should be combined into a full status report (<a class="el" href="struct_tomographer_1_1_multi_proc_1_1_full_status_report.html">Tomographer::MultiProc::FullStatusReport</a>), and the status report handler (set by <em>setStatusReportHandler()</em>) should be called.</p>
<p class="startli">The same holds if a status report is periodically due because a periodic status report was enabled (e.g. with <em>requestPeriodicStatusReport()</em> called before tasks were started). In this case it is the TaskManagerIface which should tell the task to submit a status report every so many milliseconds using the same interface.</p>
</li>
<li>After all tasks have completed, call the results collectors' <em>runsFinished()</em> method to finalize the results.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The tasks, the results collector and the constant data structure do NOT know in which kind of multiprocessing environment they will be run (they just express some abstract task to be carried out). Any data protection, data race conditions, approprate thread locking, communication of results across processes, or whatever other housekeeping is required is the task dispatcher's responsibility; not that of the tasks. See <a class="el" href="class_tomographer_1_1_multi_proc_1_1_o_m_p_1_1_task_dispatcher.html">Tomographer::MultiProc::OMP::TaskDispatcher</a> for an example; there, sections where data could be accessed simultaneously by different threads are protected by <code>#pragma omp critical</code> blocks.</dd></dl>
<h3>The API exposed by the task dispatcher</h3>
<p>The exact APIs of how these tasks are specified, managed and run is not clearly specified, but it is strongly advised to follow a model such as the simplistic <a class="el" href="class_tomographer_1_1_multi_proc_1_1_sequential_1_1_task_dispatcher.html">Tomographer::MultiProc::Sequential::TaskDispatcher</a> or the OpenMP-based <a class="el" href="class_tomographer_1_1_multi_proc_1_1_o_m_p_1_1_task_dispatcher.html">Tomographer::MultiProc::OMP::TaskDispatcher</a>.</p>
<p>The <em>TaskDispatcher</em> must however provide the following methods:</p>
<dl class="section user"><dt>void setStatusReportHandler(Fn fn)</dt><dd>The argument should be a callable (e.g. lambda function) which accepts a single paramter of const reference to a <em>FullStatusReportType</em>.</dd></dl>
<dl class="section user"><dt>void requestStatusReport()</dt><dd>Initiate a status report query. The call will typically return immediately, and sometime later the callback set by <em>setStatusReportHandler()</em> will be called with the relevant status report information.</dd></dl>
<p>This function should be safe to be called from a signal handler. This requirement severly limits what this function can do &ndash; the best usually is simply to set a value to a <code>volatile std::sig_atomic_int</code> flag (or another <code><a class="elRef" doxygen="/Users/philippe/Research/projects/tomographer/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/atomic/atomic.html">std::atomic</a></code> type). See <a href="http://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler">http://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler</a> and <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03_03">http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03_03</a></p>
<dl class="section user"><dt>void requestPeriodicStatusReport(int milliseconds)</dt><dd>Request that the task manager periodically send a status report to the handler set by <em>setStatusReportHandler()</em>. The interval time is specified in milliseconds. Pass the value <code>-1</code> to disable periodic status reports.</dd></dl>
<dl class="section user"><dt>void requestInterrupt()</dt><dd>Interrupt all tasks as soon as possible.</dd></dl>
<p>This function should be safe to be called from a signal handler. This requirement severly limits what this function can do &ndash; the best usually is simply to set a value to a <code>volatile std::sig_atomic_int</code> flag (or another <code><a class="elRef" doxygen="/Users/philippe/Research/projects/tomographer/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/atomic/atomic.html">std::atomic</a></code> type). See <a href="http://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler">http://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler</a> and <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03_03">http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03_03</a></p>
<p>The <em>TaskDispatcher</em> must also provide the following typedefs:</p>
<dl class="section user"><dt>typedef ... TaskType;</dt><dd>The <a class="el" href="page_interface_task.html">Task Interface</a> -compliant type used to describe a task.</dd></dl>
<dl class="section user"><dt>typedef .. FullStatusReportType;</dt><dd>A specialized type (or subclass) of <a class="el" href="struct_tomographer_1_1_multi_proc_1_1_full_status_report.html">Tomographer::MultiProc::FullStatusReport</a> which is passed as parameter to the callback function given to <em>setStatusReportHandler()</em> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!--
 * This file is part of the Tomographer project, which is distributed under the
 * terms of the MIT license.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 ETH Zurich, Institute for Theoretical Physics, Philippe Faist
 * Copyright (c) 2017 Caltech, Institute for Quantum Information and Matter, Philippe Faist
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">%Tomographer C++ Framework: API Documentation</a></li><li class="navelem"><a class="el" href="page_type_interfaces.html">Type Interfaces</a></li><li class="navelem"><a class="el" href="page_task_manager_dispatcher.html">Multiprocessing Task Interfaces</a></li>
    <li class="footer">Generated on Fri May 4 2018 16:57:54 for Tomographer by
    <a href="http://www.doxygen.org/index.html">
    Doxygen 1.8.12</a> </li>
  </ul>
</div>
<!-- and now, plug in our script to tweak the page: -->
<script type="text/javascript" src="tomographer_script_setup.js"></script>
</body>
</html>
