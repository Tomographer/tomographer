<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tomorun, the main tomography routine (tomographer.tomorun) &#8212; Tomographer Python Interface v5.2 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'v5.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Utilities for Metropolis-Hastings random walk tasks (tomographer.mhrwtasks)" href="tomographer.mhrwtasks.html" />
    <link rel="prev" title="Storing Tomography Data and Calculating the Likelihood Function (tomographer.densedm)" href="tomographer.densedm.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tomographer.tomorun">
<span id="tomorun-the-main-tomography-routine-tomographer-tomorun"></span><h1>Tomorun, the main tomography routine (<cite>tomographer.tomorun</cite>)<a class="headerlink" href="#module-tomographer.tomorun" title="Permalink to this headline">¶</a></h1>
<p>Perform a random in the full state space of a quantum system according to our practical, reliable procedure, and collect a histogram of a specific figure of merit.</p>
<dl class="exception">
<dt id="tomographer.tomorun.TomorunInvalidInputError">
<em class="property">exception </em><code class="descclassname">tomographer.tomorun.</code><code class="descname">TomorunInvalidInputError</code><a class="headerlink" href="#tomographer.tomorun.TomorunInvalidInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tomographer._exc_classes.html#tomographer.TomographerCxxError" title="tomographer.TomographerCxxError"><code class="xref py py-class docutils literal"><span class="pre">tomographer.TomographerCxxError</span></code></a></p>
<p>Exception which gets raised if invalid input is supplied to the <a class="reference internal" href="#tomographer.tomorun.tomorun" title="tomographer.tomorun.tomorun"><code class="xref py py-func docutils literal"><span class="pre">tomographer.tomorun.tomorun()</span></code></a> function.</p>
</dd></dl>

<dl class="function">
<dt id="tomographer.tomorun.tomorun">
<code class="descclassname">tomographer.tomorun.</code><code class="descname">tomorun</code><span class="sig-paren">(</span><em>dim</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#tomographer.tomorun.tomorun" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a histogram of a figure of merit during a random walk in quantum state
space according to the distribution <span class="math">\(\mu_{B^n}(\cdot)\)</span> defined in Ref. [1]. The
likelihood function is specified with independent POVM effects (see below).
This python function provides comparable functionality to the <cite>tomorun</cite> executable program, and
allows for a better seamless interoperability with <cite>NumPy</cite>&#8212;all data matrices here are specified
as <cite>NumPy</cite> arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; The dimension of the quantum system</li>
<li><strong>Exn</strong> &#8211; The observed POVM effects, specified as a matrix in which each row is the
X-parameterization of a POVM effect. You may want to specify <cite>Emn</cite> instead,
which may be simpler.</li>
<li><strong>Emn</strong> &#8211; The observed POVM effects, specified as a list of <span class="math">\(\textit{dim}\times\textit{dim}\)</span>
matrices.</li>
<li><strong>Nm</strong> &#8211; the list of observed frequency counts for each POVM effect in <cite>Emn</cite> or <cite>Exn</cite>.</li>
<li><strong>fig_of_merit</strong> &#8211; The choice of the figure of merit to study.  This is either a Python string or a
Python callable.  If it is a string, it must be one of &#8216;obs-value&#8217;,
&#8216;fidelity&#8217;, &#8216;tr-dist&#8217; or &#8216;purif-dist&#8217; (see below for more info).  If it is a callable, it
should accept a single argument, the T-parameterization of the density matrix, and should
calculate and return the figure of merit.  The T-parameterization is a matrix <span class="math">\(T\)</span>
that <span class="math">\(\rho=TT^\dagger\)</span>.</li>
<li><strong>ref_state</strong> &#8211; For figures of merit which compare to a reference state (&#8216;fidelity&#8217;, &#8216;tr-dist&#8217;,
and &#8216;purif-dist&#8217;), this is the reference state to calculate the figure of merit with,
specified as a density matrix.</li>
<li><strong>observable</strong> &#8211; For the &#8216;obs-value&#8217; figure of merit, specify the observable here as a matrix.</li>
<li><strong>hist_params</strong> &#8211; The requested range of values to look at when collecting a histogram of the
figure of mert.  This should be a <a class="reference internal" href="tomographer._hist_classes.html#tomographer.HistogramParams" title="tomographer.HistogramParams"><code class="xref py py-class docutils literal"><span class="pre">tomographer.HistogramParams</span></code></a>
instance.</li>
<li><strong>mhrw_params</strong> &#8211; The parameters of the random walk, including the step size, the sweep size,
the number of thermalization sweeps, and the number of live sweeps.  Specify a
<a class="reference internal" href="tomographer._mhrw_classes.html#tomographer.MHRWParams" title="tomographer.MHRWParams"><code class="xref py py-class docutils literal"><span class="pre">tomographer.MHRWParams</span></code></a> instance here.</li>
<li><strong>binning_num_levels</strong> &#8211; The number of levels in the binning analysis [2]. One should make sure
that there are enough bins at the last level to estimate the standard
deviation. This is done automatically by default (or if you specify the value <cite>-1</cite>),
so in normal circumstances you won&#8217;t have to change the default value.</li>
<li><strong>num_repeats</strong> &#8211; The number of independent random walks to run in parallel.</li>
<li><strong>progress_fn</strong> &#8211; A python callback function to monitor progress.  The function should accept
a single argument of type <a class="reference internal" href="tomographer.multiproc.html#tomographer.multiproc.FullStatusReport" title="tomographer.multiproc.FullStatusReport"><code class="xref py py-class docutils literal"><span class="pre">tomographer.multiproc.FullStatusReport</span></code></a>.  Check
out <a class="reference internal" href="tomographer.jpyutil.html#tomographer.jpyutil.RandWalkProgressBar" title="tomographer.jpyutil.RandWalkProgressBar"><code class="xref py py-class docutils literal"><span class="pre">tomographer.jpyutil.RandWalkProgressBar</span></code></a> if you are using a
Jupyter notebook.  See below for more information on status progress reporting.</li>
<li><strong>progress_interval_ms</strong> &#8211; The approximate time interval in milliseconds between two progress
reports.</li>
<li><strong>jumps_method</strong> &#8211; Method to use for the jumps in the random walk.  This may be either &#8220;full&#8221;
or &#8220;light&#8221;.  The &#8220;full&#8221; method is the one described in the paper, with a jump
corresponding to moving the purified bipartite state vector uniformly on the hypersphere.
The &#8220;light&#8221; method is an optimized version, where only an &#8220;elementary rotation&#8221;&#8212;a
simple qubit rotation&#8212;is applied onto two randomly chosen computational basis elements
on the purified bipartite state vector.  In the end the random walk explores the same space
with the same distribution.  The &#8220;light&#8221; can go much faster especially for large
dimensions, but may be slower to converge.</li>
<li><strong>ctrl_step_size_params</strong> &#8211; <p>A python dict with parameters to set up the controller which dynamically adjusts
the step size of the random walk during the thermalization runs. The possible keys
are:</p>
<blockquote>
<div><ul>
<li>&#8216;enabled&#8217; (set to &#8216;True&#8217; or &#8216;False&#8217;): Whether to enable the controller or not. If
disabled, the step size is not automatically adjusted.</li>
<li>&#8216;desired_accept_ratio_min&#8217;, &#8216;desired_accept_ratio_max&#8217;: The range in which we would
like to keep the acceptance ratio, by adapting the step size.</li>
<li>&#8216;acceptable_accept_ratio_min&#8217;, &#8216;acceptable_accept_ratio_max&#8217;: The range of values which
the acceptance ratio is not to exceed.</li>
<li>&#8216;ensure_n_therm_fixed_params_fraction&#8217;: Whenever the step size is adjusted, the controller
guarantees that at least this fraction of the given number <cite>n_therm</cite> of thermalization
sweeps is carried out before finishing the thermalization phase.</li>
</ul>
</div></blockquote>
<p>See also <a class="reference external" href="../class_tomographer_1_1_m_h_r_w_step_size_controller.html">this doc of the corresponding
C++ controller class</a>.</p>
</li>
<li><strong>ctrl_converged_params</strong> &#8211; <p>A dictionary to set up the controller which dynamically keeps
the random walk running while the error bars from binning haven&#8217;t converged as
required. The possible keys are:</p>
<blockquote>
<div><ul>
<li>&#8216;enabled&#8217; (set to &#8216;True&#8217; or &#8216;False&#8217;): Whether to enable the controller or not. If
disabled, the error bars of the histogram bins will not be checked for convergence before
terminating the random walk.</li>
<li>&#8216;max_allowed_unknown&#8217;, &#8216;max_allowed_unknown_notisolated&#8217;, &#8216;max_allowed_not_converged&#8217;:
The maximum allowed number of bins for which the error bars via binning analysis have 
the respective convergence status.  Only after all these requirements are met will the
random walk be allowed to finish (or until &#8216;max_add_run_iters&#8217; faction of run sweeps is
exceeded).  Default: <cite>max_allowed_unknown = 1 + 2% of num_bins</cite>,
<cite>max_allowed_unknown_notisolated = 1 + 1% of bins</cite> and
<cite>max_allowed_not_converged = 1 + .5% of bins</cite>.</li>
<li>&#8216;check_frequency_sweeps&#8217;: How often to check for the convergence
of the binning analysis error bars (in number of sweeps).</li>
<li>&#8216;max_add_run_iters&#8217;: End the random walk after a certain amount runs
regardless of bins error bars convergence status. Specify the amount as
a fraction of the set number of run sweeps, e.g. a value of 1.5 prolongs
the random walk by at most 50% of the run sweeps. Set to a negative value
to run as long as necessary to make error bars converge as requested.</li>
</ul>
</div></blockquote>
<p>See also <a class="reference external" href="../class_tomographer_1_1_m_h_r_w_value_error_bins_converged_controller.html">this doc of the corresponding
C++ controller class</a>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Figures of merit</p>
<p>The value of the <cite>fig_of_merit</cite> argument may be a Python string, in which case it should be one of
the following:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;obs-value&#8221;: the expectation value of an observable. You should specify the argument
<cite>observable</cite> as a 2-D <cite>NumPy</cite> array specifying the observable you are interested in.</li>
<li>&#8220;tr-dist&#8221;: the trace distance to a reference state. You should specify the argument
<cite>ref_state</cite> as a 2-D <cite>NumPy</cite> array specifying the density matrix of the state which should
serve as reference state.</li>
<li>&#8220;fidelity&#8221;: the (root) fidelity to a reference state [3]. You should specify the argument
<cite>ref_state</cite> as a 2-D <cite>NumPy</cite> array specifying the density matrix of the state which should
serve as reference state. (For the squared fidelity to a pure reference state, see note below.)</li>
<li>&#8220;purif-dist&#8221;: the purified distance to a reference state [5]. You should specify the argument
<cite>ref_state</cite> as a 2-D <cite>NumPy</cite> array specifying the density matrix of the state which should
serve as reference state.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the squared fidelity to a pure state (usually preferred in experimental papers),
you should use &#8220;obs-value&#8221; with the observable being the density matrix of the
reference state [4].</p>
</div>
<p>The value of the <cite>fig_of_merit</cite> argument may also be a Python callable which directly calculates the
figure of merit.  It should accept a single argument, the T-parameterization of the density matrix
given as a <cite>NumPy</cite> array (defined such that <span class="math">\(\rho=TT^\dagger\)</span>), and should return the value
of the figure of merit.  For example, to calculate the purity of the state
<span class="math">\(\operatorname{tr}(\rho^2)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">npl</span>
<span class="o">...</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">tomographer</span><span class="o">.</span><span class="n">tomorun</span><span class="o">.</span><span class="n">tomorun</span><span class="p">(</span><span class="o">...</span><span class="p">,</span>
                                <span class="n">fig_of_merit</span><span class="o">=</span><span class="k">lambda</span> <span class="n">T</span><span class="p">:</span> <span class="n">npl</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())),</span>
                                <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Return value</p>
<p>The <cite>tomorun()</cite> function returns a Python dictionary with the following keys and values set:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">final_histogram</span></code>: a <a class="reference internal" href="tomographer._hist_classes.html#tomographer.HistogramWithErrorBars" title="tomographer.HistogramWithErrorBars"><code class="xref py py-class docutils literal"><span class="pre">HistogramWithErrorBars</span></code></a> instance with the final histogram data.  The histogram has the parameters specified in the <cite>hist_params</cite> argument. The histogram is NOT normalized to a probabilty density; you should call its  <a class="reference internal" href="tomographer._hist_classes.html#tomographer.HistogramWithErrorBars.normalized" title="tomographer.HistogramWithErrorBars.normalized"><code class="xref py py-meth docutils literal"><span class="pre">normalized()</span></code></a> method if you need a  normalized histogram.</li>
<li><code class="docutils literal"><span class="pre">simple_final_histogram</span></code>: a <a class="reference internal" href="tomographer._hist_classes.html#tomographer.HistogramWithErrorBars" title="tomographer.HistogramWithErrorBars"><code class="xref py py-class docutils literal"><span class="pre">HistogramWithErrorBars</span></code></a> obtained from averaging the raw histograms from each task run, ignoring their error bars from the binning analysis.  Under normal circumstances there is no reason you should ignore the binning analysis, so normally you should not be using this member.  This member is only useful if you want to test the error bars from the binning analysis against &#8220;naive&#8221; error bars</li>
<li><code class="docutils literal"><span class="pre">elapsed_seconds</span></code>: the total time elapsed while running the random walks, in seconds.</li>
<li><code class="docutils literal"><span class="pre">final_report_runs</span></code>: a human-readable summary report of each task run.  Allows the user to visually check that all error bars have converged in the binning analysis, and to get an approximate visual representation of what the histogram looks like for each run.</li>
<li><code class="docutils literal"><span class="pre">final_report</span></code>: a human-readable summary of the whole procedure. This includes the final report of all the runs contained in <code class="docutils literal"><span class="pre">final_report_runs</span></code>, as well as a visual representation of the final averaged histogram.</li>
<li><code class="docutils literal"><span class="pre">runs_results</span></code>: a list of all the raw results provided by each task run.  Each item of the list is an instance of <a class="reference internal" href="tomographer.mhrwtasks.html#tomographer.mhrwtasks.MHRandomWalkTaskResult" title="tomographer.mhrwtasks.MHRandomWalkTaskResult"><code class="xref py py-class docutils literal"><span class="pre">tomographer.mhrwtasks.MHRandomWalkTaskResult</span></code></a>, with its <cite>stats_results</cite> member being a instance of <a class="reference internal" href="tomographer._mhrw_classes.html#tomographer.ValueHistogramWithBinningMHRWStatsCollectorResult" title="tomographer.ValueHistogramWithBinningMHRWStatsCollectorResult"><code class="xref py py-class docutils literal"><span class="pre">tomographer.ValueHistogramWithBinningMHRWStatsCollectorResult</span></code></a>.</li>
</ul>
</div></blockquote>
<p class="rubric">Status reporting</p>
<p>You may receive periodic status reports via a custom Python callback, so that you can stay informed of the overall progress.  The callback specified to <cite>progress_fn</cite> will be called approximately every <cite>progress_interval_ms</cite> milliseconds with information on the overall progress given as a <a class="reference internal" href="tomographer.multiproc.html#tomographer.multiproc.FullStatusReport" title="tomographer.multiproc.FullStatusReport"><code class="xref py py-class docutils literal"><span class="pre">tomographer.multiproc.FullStatusReport</span></code></a> object.  The individual workers provide the following additional information, formatted within the <cite>data</cite> dictionary attribute of each <a class="reference internal" href="tomographer.multiproc.html#tomographer.multiproc.WorkerStatusReport" title="tomographer.multiproc.WorkerStatusReport"><code class="xref py py-class docutils literal"><span class="pre">WorkerStatusReport</span></code></a> object:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">data['mhrw_params']</span></code> &#8211; a <a class="reference internal" href="tomographer._mhrw_classes.html#tomographer.MHRWParams" title="tomographer.MHRWParams"><code class="xref py py-class docutils literal"><span class="pre">MHRWParams</span></code></a> instance with the current parameters of the random walk</li>
<li><code class="docutils literal"><span class="pre">data['acceptance_ratio']</span></code> &#8211; the current acceptance ratio of the Metropolis-Hastings random walk, as a real value between zero and one. You should try to keep this value around ~0.25.  The acceptance ratio is not available during the thermalizing runs.</li>
<li><code class="docutils literal"><span class="pre">data['kstep']</span></code> &#8211; the current iteration step number (an iteration corresponds to creating a jump proposal, and to jump with a certain probability)</li>
<li><code class="docutils literal"><span class="pre">data['n_total_iters']</span></code> &#8211; the total number of iterations this random walk is going to complete. This is equal to <code class="docutils literal"><span class="pre">n_sweep*(n_therm</span> <span class="pre">+</span> <span class="pre">n_run)</span></code>.</li>
</ul>
</div></blockquote>
<p class="rubric">Footnotes and references</p>
<div class="line-block">
<div class="line">[1] Christandl and Renner, Phys. Rev. Lett. 12:120403 (2012), arXiv:1108.5329</div>
<div class="line">[2] Ambegaokar and Troyer, Am. J. Phys., 78(2):150 (2010), arXiv:0906.0943</div>
<div class="line">[3] The root fidelity is defined as <span class="math">\(F(\rho,\sigma)=\left\Vert\rho^{1/2}\sigma^{1/2}\right\Vert_1\)</span>, as in Nielsen and Chuang, &#8220;Quantum Computation and Quantum Information&#8221;.</div>
<div class="line">[4] Indeed, for pure <span class="math">\(\rho_\mathrm{ref}\)</span>, <span class="math">\(F^2(\rho,\rho_\mathrm{ref}) = \mathrm{tr}(\rho\rho_\mathrm{ref})\)</span>.</div>
<div class="line">[5] The purified distance, also called &#8220;infidelity&#8221; in the literature, is defined as <span class="math">\(P(\rho,\sigma) = \sqrt{1 - F^2(\rho,\sigma)}\)</span>.</div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Tomographer Python Interface</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tomographer._hist_classes.html">Histogram Classes (<cite>tomographer</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer._mhrw_classes.html">Metropolis-Hastings Random Walk related classes (<cite>tomographer</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer._exc_classes.html">Exception Classes (<cite>tomographer</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.multiproc.html">Multiprocessing related classes (<cite>tomographer.multiproc</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.densedm.html">Storing Tomography Data and Calculating the Likelihood Function (<cite>tomographer.densedm</cite>)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tomorun, the main tomography routine (<cite>tomographer.tomorun</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.mhrwtasks.html">Utilities for Metropolis-Hastings random walk tasks (<cite>tomographer.mhrwtasks</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.querrorbars.html">Computing the quantum error bars (<cite>tomographer.querrorbars</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.tools.html">Python Tools Related to Tomography (<cite>tomographer.tools</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.jpyutil.html">Utilities for Jupyter notebooks (<cite>tomographer.jpyutil</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.include.html">Utilities for compiling other modules (<cite>tomographer.include</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tomographer.version.html">Version and compilation information (<cite>tomographer.version</cite>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_module.html">Writing Special-Purpose C++ Code with a Python Interface</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="tomographer.html">&lt;no title&gt;</a><ul>
      <li>Previous: <a href="tomographer.densedm.html" title="previous chapter">Storing Tomography Data and Calculating the Likelihood Function (<cite>tomographer.densedm</cite>)</a></li>
      <li>Next: <a href="tomographer.mhrwtasks.html" title="next chapter">Utilities for Metropolis-Hastings random walk tasks (<cite>tomographer.mhrwtasks</cite>)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Philippe Faist.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/tomographer.tomorun.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>